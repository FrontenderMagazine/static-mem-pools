# Javascript с использованием статической памяти и пулов объектов

## Введение

Вы получаете имейл с жалобой на то, что ваша браузерная игра или приложение 
после некоторого отрезка времени перестает нормально работать, копаетесь в коде 
и не находите ничего из ряда вон выходящего, пока не открываете инструмент 
мониторинга памяти в Chrome и видите следующее:

![диаграмма1][Интересно что это еще за зубцы?]

*Один из ваших сотрудников тихо посмеивается, увидев, что вам предстоит решать 
проблемы производительности, связанные с памятью.*

Зубчатый вид диаграммы потребления памяти явственно свидетельствует о проблеме 
производительности, которая, вполне возможно, является критической. По мере 
роста потребления памяти, мы видим сопутствующее нарастание на диаграмме. В 
месте резкого спада кривой на диаграмме, происходит запуск программы чистки 
памяти и удаление кэшированных объектов. 

![диаграмма2][Только взгляните сколько раз запускается очистка памяти!]

По этой диаграмме чётко видно насколько часто происходит очистка памяти, что не 
может не сказываться на производительности веб-приложения. В этой статье мы 
поговорим о том, как можно управлять использованием памяти, уменьшая негативное 
воздействие для производительность.

## Сборка мусора и влияние на производительность

В основу [Модели памяти][1] в JavaScript заложена технология, известная под 
названием [сборка мусора][2]. Многие языки возлагают прямую ответственность за 
распределение и освобождение памяти из динамической памяти системы на 
программиста. Система сборки мусора выполняет эту задачу вместо программиста, 
освобождая память от объектов не сразу же после того, как программист удаляет 
ссылку на них, а немного позже, когда сборщик мусора путем эвристического 
анализа определяет наиболее подходящий для этого момент. Для выбора такого 
момента требуется проведение статистического анализа активных и неактивных 
объектов, занимающее определённое количество времени.

> [Сборка мусора][4] в информатике представляет собой одну из форм 
автоматического управления памятью. Сборщик мусора осуществляет попытку очистить 
мусор, то есть память, занятую объектами, которые больше не используются 
программой.

> Процесс сборки мусора часто противопоставляют ручному управлению памятью, при 
котором программист уточняет какие объекты следует открепить и вернуть в систему 
памяти.

Процесс восстановления памяти сборщиком мусора не является дармовым, для него 
обычно используется часть доступной производительности и на его выполнение 
затрачивается определённое количество времени; кроме того, решение о 
необходимости своего запуска принимает сама система. Это действие вы 
контролировать не имеете возможности, запуск сборщика мусора может произойти в 
любой момент во время выполнения кода, что приведёт к блокировке выполнения кода 
до завершения его работы. Длительность работы сборщика мусора, как правило, 
нельзя предсказать; она зависит от того, как используется память в данный момент.

Для обеспечения бесперебойного взаимодействия с пользователями в 
[высокопроизводительных][5] приложениях накладывается ограничение 
последовательной работы. Системы сборки мусора могут нарушить бесперебойность 
работы приложения, так как они запускаются в произвольный момент и длятся 
произвольное количество времени, воруя ресурсы, которые нужны приложению для 
достижения целевых показателей производительности.

### Сокращение псевдо-утечек памяти, уменьшение нагрузки от сборки мусора

Как упоминалось ранее, запуск сборщика мусора происходит после того, как с 
помощью набора эвристических алгоритмов определяется наличие достаточного 
количества неактивных объектов и целесообразность этого запуска. По сути, 
ключевой принцип сокращения времени, отбираемого сборщиком мусора у приложения, 
состоит в сведении к минимуму создания и удаления временных объектов. Процесс 
частого создания и удаления объектов называют «псевдо-утечкой памяти». Если есть 
возможность сократить псевдо-утечку памяти при эксплуатации приложения, 
сократится также и время, затрачиваемое на работу сборщика мусора. Это значит, 
что следует отказаться от создания и уничтожения объектов или же сократить их 
количество; по существу, вам нужно прекратить распределение памяти. Это даст вам 
вместо такой диаграммы использования памяти: 

![диаграмма3][Интересно что это еще за зубцы?]

такую: 

![диаграмма4][Вот так то лучше.]

На этой диаграмме видно, что кривая уже не имеет зубчатую форму, вместо этого 
она совершает значительный скачок вверх в начале и со временем еще постепенно 
возрастает. Если проблемы с памятью вызваны её псевдо-утечкой, вам следует 
стремиться к получению именно такой диаграммы.

## Переход к JavaScript на основе статической памяти

*JavaScript на основе статической памяти* является подходом, предусматривающим 
[предварительное распределение][7] всей памяти, которая потребуется для 
эксплуатации приложения, производимое при его запуске, а также управление этой 
памятью в процессе его выполнения, когда объекты становятся ненужными. Этого 
можно достичь в несколько простых шагов:

1. Измерение и определение максимального количества активных объектов (каждого 
типа), необходимого для диапазона сценариев использования
2. Перенастройка кода так, чтобы это максимальное количество назначалось 
предварительно, а затем выполнялся ручной вызов и освобождение, вместо создания 
из основной памяти. 

На практике перед тем как приступить к шагу №1, нужно частично выполнить шаг №2, 
потому с него и начнём.

### Пул объектов

Простыми словами, [пул объектов][8] — это способ хранения нескольких 
неиспользуемых объектов общего типа. Когда для кода нужен новый объект, вы 
используете один из объектов, хранящихся в пуле, вместо того чтобы создавать 
новый из [динамической памяти][9] системы. Когда объект больше не требуется для 
внешнего кода, вместо того чтобы освобождаться в основную память, он 
возвращается в пул. Поскольку [удаление ссылки][10] на объект в коде не 
происходит, он не является мусором, подлежащим сборке. **Использование пула 
объектов возвращает контроль над памятью в руки программиста, уменьшая влияние 
сборщика мусора на производительность.**

Пулы объектов часто используются в приложениях с высокой производительностью, 
поскольку позволяют уменьшить объем псевдо-утечки памяти, возлагаемый на систему. 
Пулы объектов в свою очередь обладают двумя свойствами:

1. Объем памяти, требуемой для пула объектов, растёт по мере увеличения 
количества используемых объектов.
2. Количество объектов, создаваемых и удаляемых в конкретный отрезок времени 
сокращается до минимума, требуемого для приложения. 

Поскольку существует ряд разнообразных типов объектов, поддерживаемых 
приложением, чтобы эффективно использовать пулы объектов, вам потребуется 
отдельный пул для каждого типа, активно используемого во время работы приложения.

    var newEntity = gEntityObjectPool.allocate();
    newEntity.pos = {x: 215, y: 88};

    //..... выполнение действий с объектом

    gEntityObjectPool.free(newEntity); //освобождение этого объекта после окончания действий
    newEntity = null; //удаление ссылки на этот объект

При разработке подавляющего большинства приложений, вы рано или поздно 
достигнете той границы, когда появится необходимость назначить новые объекты. 
После нескольких прогонов приложения вы должны в достаточной мере понять где 
находится этот предел и суметь предусмотреть достаточное количество объектов, 
создаваемых при запуске приложения.

### Предварительное определение объектов

Внедрение пулов объектов в проект даст вам теоретический максимум количества 
объектов, необходимых во время работы приложения. После тестирования сайта с 
помощью различных сценариев, вы получите чёткое представление о требованиях к 
памяти, с которыми предстоит иметь дело, сможете каталогизировать и 
проанализировать эти данные, чтобы определить предельные требования к памяти у 
вашего приложения.

Затем в коммерческой версии приложения можно запрограммировать предварительное 
наполнение указанного количества пулов объектов на этапе инициализации. Это 
позволит перенести инициализацию объектов полностью на начальную стадию работы 
приложения и сократить необходимость в их динамическом назначении во время 
эксплуатации приложения. 

    function init() {
      //предварительное назначение всех пулов. 
      //обратите внимание, что в каждом пуле хранятся однотипные объекты
      gEntityObjectPool.preAllocate(256);
      gDomObjectPool.preAllocate(888);
    }

Выбранное количество сильно зависит от поведения вашего приложения; иногда 
теоретический максимум будет не лучшим вариантом. Например, если вы выберете 
средний максимум, в руках не слишком продвинутого пользователя объем требуемой 
памяти для работы приложения будет меньшим. 

### Мы не ищем простых путей

Существует целая классификация приложений, для которых подход статического 
увеличения памяти может оказаться выигрышным. Однако, как отметил коллега из 
Chrome [Ренато Мангини (Renato Mangini)][11], есть несколько подводных камней.

> Пулы подойдут не всем, даже когда речь идёт о высокопроизводительных 
приложениях. Перед тем как начать использовать пулы объектов и методы на основе 
статической памяти, учтите следующие побочные эффекты: время запуска приложения 
увеличится за счёт выполнения циклов для распределения памяти на этапе 
инициализации. В экономном режиме работы объем используемой памяти не будет 
уменьшаться; ваше приложение будет потреблять память всё так же жадно. Иногда 
может возникнуть необходимость очистить объект после возвращения в пул, это 
может привести к нетривиальному перерасходу ресурсов в отрезках с высокой 
псевдо-утечкой памяти.

## Заключение

Одна из причин того, что JavaScript идеально подходит для веб, состоит в том, 
что этот язык быстрый, интересный и простой в работе. Этим он в основном обязан 
низкому барьеру для синтаксических ограничений и возможности управлять памятью 
вместо вас. Вы можете сосредоточиться на написании кода и оставить всю грязную 
работу на него. Однако в случае с высокопроизводительными веб-приложениями вроде 
[игр на HTML5][12], сборщик мусора может «съесть» критически важную кадровую 
частоту с негативными последствиями для опыта конечного пользователя. Уделив 
должное внимание мониторингу и внедрив пулы объектов, можно снять это бремя с 
кадровой частоты и использовать её для чего-то поинтересней.

## Исходный код

В интернете можно найти много вариантов реализации пулов объектов, так что я не 
буду отнимать у вас время описанием очередного из них. Вместо этого хочу 
предложить вам ссылки на несколько вариантов, каждый из которых обладает 
некоторыми нюансами в реализации, что очень важно, так как у каждого приложения 
возникают свои специфические требования к реализации. 

* [Пул объектов Gamecore.js][14]
* [Пулы объектов от Beej][15]
* [Супер простой пул объектов от Emehrkay][16]
* [Пул объектов для игр от Стивена Ламберта (Steven Lambert)][17]
* [Настройка пула объектов для движка RenderEngine][18]

## Дополнительные ссылки

* [Код, совместимый со Сборщиком мусора][19]
* [Приручаем единорога: упрощенное профилирование памяти Javascript с 
использованием Инструментов Разработчика][20]
* [Пишем быстрый и эффективный javascript][21]

[1]: http://en.wikipedia.org/wiki/Memory_model_%28programming%29
[2]: http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29
[3]: https://en.wikipedia.org/wiki/Memory_management
[4]: http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29
[5]: https://en.wikipedia.org/wiki/Supercomputer
[6]: http://en.wikipedia.org/wiki/Sawtooth_wave
[7]: http://en.wikipedia.org/wiki/Sawtooth_wave
[8]: http://en.wikipedia.org/wiki/Object_pool_pattern
[9]: https://en.wikipedia.org/wiki/Memory_management
[10]: http://en.wikipedia.org/wiki/Reference_%28computer_science%29
[11]: https://plus.google.com/u/0/+RenatoMangini/posts
[12]: https://www.udacity.com/course/cs255
[13]: http://en.wikipedia.org/wiki/Frame_rate
[14]: https://github.com/martinwells/gamecore.js/blob/master/src/pooled.js
[15]: http://beej.us/blog/data/object-pool/
[16]: https://github.com/emehrkay/Pool
[17]: http://blog.sklambert.com/javascript-object-pool/
[18]: https://code.google.com/p/renderengine/wiki/ObjectPooling
[19]: http://buildnewgames.com/garbage-collector-friendly-code/
[20]: http://addyosmani.com/blog/taming-the-unicorn-easing-Javascript-memory-profiling-in-devtools/
[21]: http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-Javascript/#more-123093

[Интересно что это еще за зубцы?]: img/fig1.jpg
[Только взгляните сколько раз запускается очистка памяти!]: img/fig2.jpg
[Вот так то лучше.]: img/fig3.jpg