# Javascript с использованием статической памяти и пулов объектов

## Введение

Вы получаете имейл с жалобой на то что ваша браузерная игра или приложение после некоторого отрезка времени перестает нормально работать, копаетесь в коде и не находите ничего из ряда вон выходящего пока не открываете инструмент мониторинга памяти в Chrome и видите следующее:

![диаграмма1][Интересно что это еще за зубцы?]

*Один из ваших сотрудников тихо посмеивается, увидев что вам предстоит решать проблемы производительности связанные с памятью.*

Зубчастый вид диаграммы потребления памяти явственно свидетельствует о проблеме производительности, которая вполне возможно является критической. По мере роста потребления памяти мы видим сопутствующее нарастание на диаграмме. В месте резкого понижения на диаграмме, происходит запуск программы чистки памяти и удаление кешированных объектов. 

![диаграмма2][Только взгляните сколько раз запускается очистка памяти!]

Такая диаграмма показывает насколько часто происходит очистка памяти, что не может не сказываться на производительности веб-приложения. В этой статье мы поговорим о том, как можно управлять использованием памяти, уменьшая негативные последствия для производительности.

## Сборка мусора и влияние на производительность

[Модель памяти][1] в JavaScript строится на технологии известной под названием [Сборка мусора][2]. Многие языки предусматривают прямую ответственность программиста за распределение и освобождение памяти из динамической памяти системы. Система сборки мусора выполняет эту задачу от имени программиста, освобождая память от объектов не сразу же после того как программист удаляет ссылку на них, а немного позже, когда сборщик мусора путем эвристического анализа определяет наиболее подходящий момент. Для выбора такого момента требуется проведение сборщиком мусора статистического анализа активных и неактивных объектов, для выполнения которого нужно определённое количество времени.

> [Сборка мусора][4] в информатике представляет собой одну из форм автоматического управления памятью. Сборщик мусора осуществляет попытку очистить мусор, то есть память, занятую объектами, которые больше не используются программой.

> Процесс сборки мусора часто описывают как противоположный ручному управлению памятью, при котором программист уточняет какие объекты следует открепить и вернуть в систему памяти.

Процес восстановления памяти сборщиком мусора не является дармовым, для него обычно используется часть доступной производительности и на его выполнение затрачивается определённое количество времени; кроме того, система сама принимает решение когда запускаться. Это действие вы контролировать не имеете возможности, запуск сборщика мусора может произойти в любой момент во время выполнения кода, что приведёт к блокировке выполнения кода до завершения работы сборщика мусора. Длительность его работы как правило нельзя предсказать; она зависит от того как программа использует память в данный момент.

Для обеспечения бесперебойного взаимодействия с пользователями в [высокопроизводительных][5] приложениях накладывается ограничение последовательной работы. Системы сборки мусора могут нарушить бесперебойность работы приложения, так как они запускаются в произвольный момент и длятся произвольное количество времени, воруя ресурсы, которые нужны приложению для достижения целевых показателей производительности.

### Сокращение псевдо-утечек памяти, уменьшение нагрузки от сборки мусора

Как упоминалось ранее, запуск сборщика мусора происходит после того как с помощью набора эвристических алгоритмов определяется наличие достаточного количества неактивных объектов и целесообразность этого запуска. По сути, ключевой принцип сокращения времени, отбираемого сборщиком мусора у приложения, состоит в сведении к минимуму создания и удаления временных объектов. Процесс частого создания и удаления объектов называют «псевдо-утечкой памяти». Если есть возможность сократить псевдо-утечку памяти при эксплуатации приложения, сократится также и время, затрачиваемое на работу сборщика мусора. Это значит что следует отказаться от создания и уничтожения объектов или же сократить их количество, по существу, вам нужно прекратить распределение памяти. Это даст вам вместо такой диаграммы использования памяти: 

![диаграмма3][Интересно что это еще за зубцы?]

такую: 

![диаграмма4][Вот так то лучше.]

На этой диаграмме видно что кривая уже не имеет зубчастую форму, вместо этого она совершает значительный скачок вверх в начале и со временем еще постепенно возрастает. Если проблемы с памятью вызваны её псевдо-утечкой, вам следует стремиться к получению именно такой диаграммы.

## Переход к JavaScript на основе статической памяти

*JavaScript на основе статической памяти* является подходом, который предусматривает [предварительное распределение][7] всей памяти которая потребуется для эксплуатации приложения производимое при его запуске, а также управление этой памятью в процессе его выполнеия когда объекты становятся ненужными. Этого можно достичь придерживаясь несколько простых шагов:

1. Измерение и определение максимального количества активных объектов (каждого типа) необходимого для диапазона сценариев использования
2. Перенастройка кода чтобы это максимальное количество назначалось предварительно, а затем ручной вызов и освобождение вместо создания из основной памяти. 

 На практике чтобы достичь №1., нужно частично выполнить шг №2, потому с него и начнём.

### Пул объектов

Простыми словами, [пул объектов][8] - это способ хранения набора неиспользуемых объектов общего типа. Когда для кода нужен новый объект, вы используете один из объектов, хранящихся в пуле, вместо того чтобы создавать новый из [динамической памяти][9] системы. Когда объект больше не требуется для внешнего кода, вместо того чтобы освобождаться в основную память, он возвращается в пул. Поскольку [удаление ссылки][10] на объект в коде не происходит, он не является мусором, который подлежит сборке. **Использование пула объектов возвращает контроль над памятью в руки программиста, уменьшая влияние сборщика мусора на производительность.**

Пулы объектов часто используются в приложениях с высокой производительностью, поскольку позволяют уменьшить объем псевдо-утечки памяти, возлагаемый на систему. Пулы объектов в свою очередь обладают двумя свойствами:

1. Объем памяти, требуемой для пула объектов, растёт по мере увеличения количества используемых объектов.
2. Количество объектов, создаваемых и удаляемых в конкретный отрезок времени сократится до минимума, требуемого для приложения. 

Поскольку существует ряд разнообразных типов объектов, поддерживаемых приложением, чтобы эффективно использовать пулы объектов, вам потребуется отдельный пул для каждого типа, который активно используется во время работы приложения.

    var newEntity = gEntityObjectPool.allocate();
    newEntity.pos = {x: 215, y: 88};

    //..... выполнение действий с объектом

    gEntityObjectPool.free(newEntity); //освобождение этого объекта после окончания действий
    newEntity = null; //удаление ссылки на этот объект

Для подавляющего большинства приложений, вы рано или поздно достигнете того уровня, когда появится необходимость назначить новые объекты. После нескольких прогонов приложения вы должны в достаточной мере понять где находится этот предел и суметь предусмотреть достаточное количество объектов, создаваемых при запуске приложения.

### Предварительное определение объектов

Внедрение пулов объектов в проект даст вам теоретический максимум количества объектов, необходимых во время работы приложения. После тестирования сайта с помощью различных сценариев, вы получите чёткое представление о требованиях к памяти, с которыми предстоит иметь дело, сможете каталогизировать и проанализировать эти данные чтобы определить предельные требования к памяти у вашего приложения.

Затем в коммерческой версии приложения можно запрограммировать предварительное наполнение указанного количества пулов объектов на этапе инициализации. Это позволит перенести инициализацию объектов полностью на начальную стадию работы приложения и сократить необходимость в их динамическом назначении во время эксплуатации приложения. 

    function init() {
      //предварительное назначение всех пулов. 
      //обратите внимание что в каждом пуле хранятся однотипные объекты
      gEntityObjectPool.preAllocate(256);
      gDomObjectPool.preAllocate(888);
    }

Выбранное количество сильно зависит от поведения вашего приложения; иногда теоретический максимум будет не лучшим вариантом. Например, если вы выберете средний максимум, объем требуемой памяти для работы приложения в руках не слишком продвинутого пользователя будет меньшим. 

### Мы не ищем простых путей

Существует целая классификация приложений, для которых шаблон статического увеличения памяти может оказаться выигрышным. Однако, как отметил коллега из Chrome [Ренато Мангини (Renato Mangini)][11], есть несколько минусов.

> Пулы подойдут не всем, даже когда речь идёт о высокопроизводительнх приложениях. Перед тем как начать использовать пулы объектов и методы на основе статической памяти, учтите следующие побочные эффекты: увеличится время запуска приложения, так как на этапе инициализации выполняются циклы для распределения памяти. Объем используемой памяти не уменьшится в экономном режиме работы; ваше приложение будет всё так же жадно потреблять память. Иногда может возникнуть необходимость очистить объект после возвращения в пул, это может привести к нетривиальному перерасходу ресурсов в отрезках с высокой псевдо-утечкой памяти.

## Заключение

Одна из причин того, что JavaScript идеально подходит для веб, состоит в том что он быстрый, интересный и простой в работе язык. Этим он в основном обязан низкому барьеру для синтаксических ограничений и возможности управлять памятью вместо вас. Вы можете сосредоточиться на написании кода и оставить всю грязную работу на него. Однако в случае с высокопроизводительными веб-приложениями вроде [игр на HTML5][12], сборщик мусора может «съесть» критически важную кадровую частоту с негативными последствиями для опыта конечного пользователя. Уделив должное внимание контролю и внедрив пулы объектов, можно снять это бремя с кадровой частоты и использовать её для чего-то поинтересней.

## Исходный код

В интернете можно найти много вариантов реализации пулов объектов, так что я не буду отнимать у вас время описанием очередного из них. Вместо этого хочу предложить вам ссылки на несколько вариантов, каждый из которых обладает некоторыми нюансами в реализации, что очень важно, так как у каждого приложения свои специфические требования к реализации. 

* [Пул объектов Gamecore.js][14]
* [Пулы объектов от Beej][15]
* [Супер простой пул объектов от Emehrkay][16]
* [Пул объектов для игр от Стивена Ламберта (Steven Lambert)][17]
* [Настройка пула объектов для движка RenderEngine][18]

## Дополнительные ссылки

* [Код, совместимый со Сборщиком мусора][19]
* [Приручаем единорога: упрощенное профилирование памяти Javascript с использованием Инструментов Разработчика][20]
* [Пишем быстрый и эффективный javascript][21]

[1]: http://en.wikipedia.org/wiki/Memory_model_%28programming%29
[2]: http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29
[3]: https://en.wikipedia.org/wiki/Memory_management
[4]: http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29
[5]: https://en.wikipedia.org/wiki/Supercomputer
[6]: http://en.wikipedia.org/wiki/Sawtooth_wave
[7]: http://en.wikipedia.org/wiki/Sawtooth_wave
[8]: http://en.wikipedia.org/wiki/Object_pool_pattern
[9]: https://en.wikipedia.org/wiki/Memory_management
[10]: http://en.wikipedia.org/wiki/Reference_%28computer_science%29
[11]: https://plus.google.com/u/0/+RenatoMangini/posts
[12]: https://www.udacity.com/course/cs255
[13]: http://en.wikipedia.org/wiki/Frame_rate
[14]: https://github.com/martinwells/gamecore.js/blob/master/src/pooled.js
[15]: http://beej.us/blog/data/object-pool/
[16]: https://github.com/emehrkay/Pool
[17]: http://blog.sklambert.com/javascript-object-pool/
[18]: https://code.google.com/p/renderengine/wiki/ObjectPooling
[19]: http://buildnewgames.com/garbage-collector-friendly-code/
[20]: http://addyosmani.com/blog/taming-the-unicorn-easing-Javascript-memory-profiling-in-devtools/
[21]: http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-Javascript/#more-123093

[[Интересно что это еще за зубцы?]]: img/fig1.jpg
[Только взгляните сколько раз запускается очистка памяти!]: img/fig2.jpg
[Вот так то лучше.]: img/fig3.jpg